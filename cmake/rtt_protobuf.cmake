if (NOT PROTOBUF_PROTOC_EXECUTABLE)
	__RTT_ARTIFACTORY_GET(protobuf)
endif()

if (NOT PROTOBUF_PROTOC_EXECUTABLE)
	message(FATAL_ERROR "Failed to load and initialize protobuf properly - PROTOBUF_PROTOC_EXECUTABLE missing")
endif()

include("python-setup")

# taken from FindProtobuf.cmake
#
# - changed to add the path where the .proto file resides to the
# include path of protoc
#
#  ====================================================================
#
# RTT_PROTOBUF_GENERATE_CPP (public function)
#   SRCS = Variable to define with autogenerated
#          source files
#   HDRS = Variable to define with autogenerated
#          header files
#   ARGN = proto files
#   DECORATOR = declspec decorators if needed
#   INCLUDE = only sensible with DECORATORS, add a special include line such as a config header
#
#  ====================================================================

function(RTT_PROTOBUF_GENERATE_CPP)

	unset (ARG_PROTOBUF)
	unset (ARG_INCLUDE)
	unset (ARG_DECORATOR)
	parse_arguments(ARG "SRCS;HDRS;PROTOBUF;DECORATOR;INCLUDE" "" ${ARGN})

	if(NOT ARG_PROTOBUF)
		message(SEND_ERROR "Error: PROTOBUF_GENERATE_CPP() called without any proto files")
		return()
	endif()

	message(STATUS "Protobuf: ${ARG_PROTOBUF}")

	# clear output variables
	set(${ARG_SRCS})
	set(${ARG_HDRS})

	set(output_headers)
	set(output_sources)

	# iterate over all input files and compile them one by one to identify all
	# the required protobuf files
	foreach(FIL ${ARG_PROTOBUF})
		get_filename_component(ABS_FIL ${FIL} ABSOLUTE)
		get_filename_component(FIL_WE ${FIL} NAME_WE)
		get_filename_component(REALPATH ${FIL} REALPATH)
		get_filename_component(PATH ${REALPATH} PATH)

		list(APPEND ${ARG_SRCS} "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb.cc")
		list(APPEND ${ARG_HDRS} "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb.h")

		set(output_header "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb.h")
		set(output_source "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb.cc")

		set(proto_file ${FIL})

		list(APPEND output_headers "${output_header}")
		list(APPEND output_sources "${output_source}")

		if (ARG_DECORATOR)
			add_custom_command(
				OUTPUT ${output_header} ${output_source}
				COMMAND ${PROTOBUF_PROTOC_EXECUTABLE} --cpp_out=dllexport_decl=${ARG_DECORATOR}:${CMAKE_CURRENT_BINARY_DIR} --proto_path ${PATH} ${REALPATH}
				COMMAND ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/cmake/amend_protobuf_header.py ${output_header} ${ARG_INCLUDE}
				DEPENDS ${proto_file}
				COMMENT "Running C++ protocol buffer compiler with decorators ${ARG_DECORATOR} on ${FIL}"
				VERBATIM )
		else ()
			add_custom_command(
				OUTPUT ${output_header} ${output_source}
				COMMAND  ${PROTOBUF_PROTOC_EXECUTABLE} --cpp_out  ${CMAKE_CURRENT_BINARY_DIR} --proto_path ${PATH} ${REALPATH}
				DEPENDS ${proto_file}
				COMMENT "Running C++ protocol buffer compiler on ${FIL}"
				VERBATIM )
		endif ()
		#message(STATUS "created: ${proto_file} -> ${output_source}")
		endforeach ()

	set(${ARG_SRCS} ${output_sources} )
	set(${ARG_HDRS} ${output_headers} )

	set_source_files_properties(${${ARG_SRCS}} ${${ARG_HDRS}} PROPERTIES GENERATED TRUE)
	set(${ARG_SRCS} ${${ARG_SRCS}} PARENT_SCOPE)
	set(${ARG_HDRS} ${${ARG_HDRS}} PARENT_SCOPE)
endfunction()
